// $Id: CycleCreators.py 344 2012-12-13 13:10:53Z krasznaa $

// Local include(s):
#include "../include/TauTauAnalysis.h"
// External include(s):
#include "../GoodRunsLists/include/TGoodRunsListReader.h"

//#include <TMath.h>

ClassImp( TauTauAnalysis );


// define cut names

const std::string TauTauAnalysis::kCutName[ TauTauAnalysis::kNumCuts ] = {
  "BeforeCuts",            // C0
  "JSON",                  // C1
  "Trigger",               // C2
  "MetFilters",            // C3
  "Lepton",                // C4
  "Tau",                   // C5
  "LeptonDR",              // C6
};

TauTauAnalysis::TauTauAnalysis()
   : SCycleBase()
   , m_jetAK4( this )
   , m_eventInfo( this )
   , m_electron( this )
   , m_muon( this )
   , m_tau( this )
   , m_missingEt( this )
   , m_genParticle( this )
   , m_pileupReweightingTool( this )
     //   , m_bTaggingScaleTool( this )   
   , m_ScaleFactorTool( this )
{

   m_logger << INFO << "Hello!" << SLogger::endmsg;
   SetLogName( GetName() );
   
   // read configuration details from XML file
   DeclareProperty("RecoTreeName", m_recoTreeName = "physics" );

   // channels
   channels_.push_back("mutau");
   channels_.push_back("eletau");

   m_catNames.clear();

   for(auto ch: channels_){
     m_catNames.push_back(ch);
   }
   

   DeclareProperty( "JetAK4Name",               m_jetAK4Name               = "jetAK4" );
   DeclareProperty( "ElectronName",             m_electronName             = "el" );
   DeclareProperty( "MuonName",                 m_muonName                 = "mu" );
   DeclareProperty( "TauName",                  m_tauName                  = "tau" );
   DeclareProperty( "MissingEtName",            m_missingEtName            = "MET" );
   DeclareProperty( "GenParticleName",          m_genParticleName          = "genParticle" );
   
   DeclareProperty( "IsData",                   m_isData                   = false );
   DeclareProperty( "IsSignal",                 m_isSignal                 = false );
   
   DeclareProperty( "AK4JetPtCut",              m_AK4jetPtCut           = 20.);
   DeclareProperty( "AK4JetEtaCut",             m_AK4jetEtaCut          = 4.7);

   DeclareProperty( "ElectronPtCut",                 m_electronPtCut              = 24. );
   DeclareProperty( "ElectronEtaCut",                m_electronEtaCut             = 2.1 );
   DeclareProperty( "ElectronD0Cut",                m_electronD0Cut             = 0.045 );
   DeclareProperty( "ElectronDzCut",                m_electronDzCut             = 0.2 );
   DeclareProperty( "ElectronIsoCut",                m_electronIsoCut             = 0.1 );
   
   DeclareProperty( "MuonPtCut",                 m_muonPtCut              = 19. );
   DeclareProperty( "MuonEtaCut",                m_muonEtaCut             = 2.1 );
   DeclareProperty( "MuonD0Cut",                m_muonD0Cut             = 0.045 );
   DeclareProperty( "MuonDzCut",                m_muonDzCut             = 0.2 );
   DeclareProperty( "MuonIsoCut",                m_muonIsoCut             = 0.15 );

   DeclareProperty( "TauPtCut",                 m_tauPtCut           = 20 );
   DeclareProperty( "TauEtaCut",                m_tauEtaCut          = 2.3  );
   DeclareProperty( "TauDzCut",                m_tauDzCut          = 0.2  );
   
   DeclareProperty( "JSONName",                 m_jsonName             = std::string (std::getenv("SFRAME_DIR")) + "/../GoodRunsLists/JSON/Cert_271036-277148_13TeV_PromptReco_Collisions16_JSON_NoL1T.txt" );

   //   DeclareProperty( "TrigSF_muonName",                 m_TrigSF_muonName             = std::string (std::getenv("SFRAME_DIR")) + "/../LepEff2016/data/Muon/SingleMuonTrigger_Z_RunBCD_prompt80X_7p65.root" ); 
   //   DeclareProperty( "IDSF_muonName",                  m_IDSF_muonName            = std::string (std::getenv("SFRAME_DIR")) + "/../LepEff2016/data/Muon/MuonID_Z_RunBCD_prompt80X_7p65.root" );
   //   DeclareProperty( "IsoSF_muonName",                  m_IsoSF_muonName            = std::string (std::getenv("SFRAME_DIR")) + "/../LepEff2016/data/Muon/MuonIso_Z_RunBCD_prompt80X_7p65.root" );
   //   DeclareProperty( "IDSF_eleName",                  m_IDSF_eleName            = std::string (std::getenv("SFRAME_DIR")) + "/../LepEff2016/data/Electron/egammaEffi.txt_SF2D.root" );
  
   
}

TauTauAnalysis::~TauTauAnalysis() {

  m_logger << INFO << "Tschoe!" << SLogger::endmsg;

}

void TauTauAnalysis::BeginCycle() throw( SError ) {

  m_logger << INFO << "BeginCycle ... " << SLogger::endmsg;
  
  mu_tau=0;
  ele_tau=0;

  // Load GRL:

  if (m_isData) {
    m_logger << INFO << "Loading GoodRunsList from file: " << m_jsonName << SLogger::endmsg;
    Root::TGoodRunsListReader reader( TString( m_jsonName.c_str() ) );
    if( ! reader.Interpret() ) {
      m_logger << FATAL << "Couldn't read in the GRL!" << SLogger::endmsg;
      throw SError( ( "Couldn't read in file: " + m_jsonName ).c_str(), SError::SkipCycle );
    }
    m_grl = reader.GetMergedGoodRunsList();
    m_grl.Summary();
    m_grl.SetName( "MyGoodRunsList" );
  
    AddConfigObject( &m_grl );
  }
  
  m_triggerNames.clear();
	
  // muon triggers
  m_triggerNames.push_back("HLT_IsoMu18_v");
  m_triggerNames.push_back("HLT_IsoMu20_v4");
  m_triggerNames.push_back("HLT_IsoMu22_v3");
  m_triggerNames.push_back("HLT_IsoMu22_eta2p1_v2");
  m_triggerNames.push_back("HLT_IsoMu24_v2");
  m_triggerNames.push_back("HLT_IsoMu27_v4");
  m_triggerNames.push_back("HLT_IsoTkMu18_v3");
  m_triggerNames.push_back("HLT_IsoTkMu20_v5");
  m_triggerNames.push_back("HLT_IsoTkMu22_eta2p1_v2");
  m_triggerNames.push_back("HLT_IsoTkMu22_v3");
  m_triggerNames.push_back("HLT_IsoTkMu24_v2");
  m_triggerNames.push_back("HLT_IsoTkMu27_v4");
  m_triggerNames.push_back("HLT_IsoMu17_eta2p1_LooseIsoPFTau20_SingleL1_v5");
  m_triggerNames.push_back("HLT_IsoMu17_eta2p1_LooseIsoPFTau20_v5");
  m_triggerNames.push_back("HLT_IsoMu19_eta2p1_LooseIsoPFTau20_SingleL1_v2");
  m_triggerNames.push_back("HLT_IsoMu19_eta2p1_LooseIsoPFTau20_v2");
  m_triggerNames.push_back("HLT_IsoMu21_eta2p1_LooseIsoPFTau20_SingleL1_v2");

  // electron triggers
  m_triggerNames.push_back("HLT_Ele23_WPLoose_Gsf_v4");
  m_triggerNames.push_back("HLT_Ele24_eta2p1_WPLoose_Gsf_v2");
  m_triggerNames.push_back("HLT_Ele25_WPTight_Gsf_v2");
  m_triggerNames.push_back("HLT_Ele25_eta2p1_WPLoose_Gsf_v2");
  m_triggerNames.push_back("HLT_Ele25_eta2p1_WPTight_Gsf_v2");
  m_triggerNames.push_back("HLT_Ele27_WPLoose_Gsf_v2");
  m_triggerNames.push_back("HLT_Ele27_WPTight_Gsf_v2");
  m_triggerNames.push_back("HLT_Ele27_eta2p1_WPLoose_Gsf_v3");
  m_triggerNames.push_back("HLT_Ele27_eta2p1_WPTight_Gsf_v3");
  m_triggerNames.push_back("HLT_Ele32_eta2p1_WPTight_Gsf_v3");
  m_triggerNames.push_back("HLT_Ele22_eta2p1_WPLoose_Gsf_LooseIsoPFTau20_SingleL1_v3");
  m_triggerNames.push_back("HLT_Ele24_eta2p1_WPLoose_Gsf_LooseIsoPFTau20_SingleL1_v2");
  m_triggerNames.push_back("HLT_Ele24_eta2p1_WPLoose_Gsf_LooseIsoPFTau20_v2");
  m_triggerNames.push_back("HLT_Ele27_eta2p1_WPLoose_Gsf_LooseIsoPFTau20_SingleL1_v2");
  m_triggerNames.push_back("HLT_Ele32_eta2p1_WPLoose_Gsf_LooseIsoPFTau20_SingleL1_v2");


  return;

}

void TauTauAnalysis::EndCycle() throw( SError ) {
   std::cout << "events in mu_tau " <<mu_tau <<std::endl;
   std::cout << "events in ele_tau " <<ele_tau <<std::endl;
   return;
}

void TauTauAnalysis::BeginInputData( const SInputData& id ) throw( SError ) {

  m_logger << INFO << "RecoTreeName:         " <<             m_recoTreeName << SLogger::endmsg;
  m_logger << INFO << "JetAK4Name:           " <<             m_jetAK4Name << SLogger::endmsg;
  m_logger << INFO << "ElectronName:         " <<             m_electronName << SLogger::endmsg;
  m_logger << INFO << "MuonName:             " <<             m_muonName << SLogger::endmsg;
  m_logger << INFO << "TauName:             " <<             m_tauName << SLogger::endmsg;
  m_logger << INFO << "GenParticleName:      " <<             m_genParticleName << SLogger::endmsg;
  
  m_logger << INFO << "IsData:           " <<                   (m_isData ? "TRUE" : "FALSE") << SLogger::endmsg;
  m_logger << INFO << "IsSignal:           " <<                 (m_isSignal ? "TRUE" : "FALSE") << SLogger::endmsg;
  
  m_logger << INFO << "ElectronPtCut:           " <<                 m_electronPtCut << SLogger::endmsg;
  m_logger << INFO << "ElectronEtaCut:           " <<                m_electronEtaCut << SLogger::endmsg;
  m_logger << INFO << "ElectronD0Cut:           " <<                 m_electronD0Cut << SLogger::endmsg;
  m_logger << INFO << "ElectronDzCut:           " <<                m_electronDzCut << SLogger::endmsg;
  m_logger << INFO << "ElectronIsoCut:           " <<                m_electronIsoCut << SLogger::endmsg;
  
  m_logger << INFO << "MuonPtCut:           " <<                 m_muonPtCut << SLogger::endmsg;
  m_logger << INFO << "MuonEtaCut:           " <<                m_muonEtaCut << SLogger::endmsg;
  m_logger << INFO << "MuonD0Cut:           " <<                m_muonD0Cut << SLogger::endmsg;
  m_logger << INFO << "MuonDzCut:           " <<                m_muonDzCut << SLogger::endmsg;
  m_logger << INFO << "MuonIsoCut:           " <<                m_muonIsoCut << SLogger::endmsg;
  
  m_logger << INFO << "TauPtCut:           " <<                 m_tauPtCut << SLogger::endmsg;
  m_logger << INFO << "TauEtaCut:           " <<                m_tauEtaCut << SLogger::endmsg;
  m_logger << INFO << "TauDzCut:           " <<                m_tauDzCut << SLogger::endmsg;
  
  
  m_logger << INFO << "JSONName:           " <<                 m_jsonName << SLogger::endmsg;
  //  m_logger << INFO << "TrigSF_muonName:           " <<                 m_TrigSF_muonName << SLogger::endmsg;
  //  m_logger << INFO << "IDSF_muonName:           " <<                 m_IDSF_muonName << SLogger::endmsg;
  //  m_logger << INFO << "IsoSF_muonName:           " <<                 m_IsoSF_muonName << SLogger::endmsg;
  //  m_logger << INFO << "IDSF_eleName:           " <<                 m_IDSF_eleName << SLogger::endmsg;


  if (!m_isData) m_pileupReweightingTool.BeginInputData( id );

 
  if (m_isData) {
    TObject* grl;
    if( ! ( grl = GetConfigObject( "MyGoodRunsList" ) ) ) {
      m_logger << FATAL << "Can't access the GRL!" << SLogger::endmsg;
      throw SError( "Can't access the GRL!", SError::SkipCycle );
    }
    m_grl = *( dynamic_cast< Root::TGoodRunsList* >( grl ) );
  }
  
  


  std::cout << " declaring variables" << std::endl; 
    
  //    TString outputname = m_outputTreeName_ch_[ch].c_str();
  TString outputname = "tree";

    DeclareVariable(b_weight_              , "weight"                 ,  outputname);

    DeclareVariable(b_weightGen_           , "weightGen"              ,  outputname);
    DeclareVariable(b_weightPU_            , "weightPU"               ,  outputname);
    //    DeclareVariable(b_weightBtag_          , "weightBtag"             ,  outputname); 
    //    DeclareVariable(b_weightBtag_veto_      , "weightBtag_veto"             ,  outputname);
    DeclareVariable( b_runNumber_,           "runNumber"            ,  outputname);
    DeclareVariable( b_eventNumber_,         "eventNumber"          ,  outputname);
    DeclareVariable( b_lumiBlock_,           "lumiBlock"            ,  outputname);
  
    DeclareVariable( b_tau_pt_,   "tau_pt"   ,  outputname);
    DeclareVariable( b_tau_eta_,   "tau_eta"   ,  outputname);
    DeclareVariable( b_tau_phi_,   "tau_phi"   ,  outputname);
    DeclareVariable( b_tau_Iso_,   "tau_iso"   ,  outputname);
    DeclareVariable( b_tau_IsoRaw_,   "tau_iso_raw"   ,  outputname);
    DeclareVariable( b_tau_againstEle_,   "tau_againstEle"   ,  outputname);
    DeclareVariable( b_tau_againstMu_,   "tau_againstMu"   ,  outputname);

    DeclareVariable( b_seclepton_pt_,   "lep2_pt"   ,  outputname);
    DeclareVariable( b_seclepton_eta_,   "lep2_eta"   ,  outputname);
    DeclareVariable( b_seclepton_phi_,   "lep2_phi"   ,  outputname);
    DeclareVariable( b_met_,   "met"   ,  outputname);
    DeclareVariable( b_met_phi_,   "met_phi"   ,  outputname);
    DeclareVariable( b_vis_mass_ll_,   "vis_mass_ll"   ,  outputname);
    DeclareVariable( b_dR_ll_,   "dR_ll"   ,  outputname);
    DeclareVariable( b_H_Mass_SVFit_,   "H_Mass_SVFit"   ,  outputname);
    DeclareVariable( b_H_Pt_SVFit_,   "H_Pt_SVFit"   ,  outputname);
    DeclareVariable( b_H_Eta_SVFit_,   "H_Eta_SVFit"   ,  outputname);
    DeclareVariable( b_H_Phi_SVFit_,   "H_Phi_SVFit"   ,  outputname);
    DeclareVariable( b_N_AK4_, "N_AK4"   ,  outputname);
    DeclareVariable( b_PV_N_, "PV_N" ,  outputname);

    DeclareVariable( b_GenEvent_Htata_, "GenEvent_Htata"   ,  outputname);
    DeclareVariable( b_GenEvent_Ztata_, "GenEvent_Ztata"   ,  outputname);
    DeclareVariable( b_ChannelInt_, "ChannelInt"   ,  outputname);
    DeclareVariable(b_weightLepID_, "weightLepID"   ,  outputname);
    DeclareVariable(b_weightLepIso_, "weightLepIso"   ,  outputname);



  for (auto ch: channels_){
    TString hname = "cutflow_" + ch;
    TString dirname = "histogram_" + ch;
    std::cout << hname << " " << dirname << std::endl;
    Book( TH1F(hname, hname, 20, 0.5, 20.5 ), dirname); 
  }

  //  m_bTaggingScaleTool.BeginInputData( id );
  m_ScaleFactorTool.BeginInputData( id );
 

  return;

}

void TauTauAnalysis::EndInputData( const SInputData& ) throw( SError ) {

  //
  // Final analysis of cut flow
  //
  
  for(auto ch: channels_){
    m_logger << INFO << "cut flow for " << ch << SLogger::endmsg;
    m_logger << INFO << Form( "Cut\t%25.25s\tEvents\tRelEff\tAbsEff", "Name" ) << SLogger::endmsg;
  
    TString hname = "cutflow_" + ch;
    TString dirname = "histogram_" + ch;

    Double_t ntot = Hist(hname, dirname)->GetBinContent( 1 );
    m_logger << INFO << Form( "\t%25.25s\t%6.0f", "start", ntot ) << SLogger::endmsg;

    for( Int_t ibin = 2; ibin <= kNumCuts; ++ibin ) {
      Int_t    icut    = ibin - 1;
      Double_t nevents = Hist(hname, dirname)->GetBinContent( ibin );
      Double_t releff  = 100. * nevents / Hist(hname, dirname)->GetBinContent( ibin-1 );
      Double_t abseff  = 100. * nevents / ntot;
      m_logger << INFO  << Form( "C%d\t%25.25s\t%6.0f\t%6.2f\t%6.2f", icut-1, kCutName[icut].c_str(), nevents, releff, abseff ) << SLogger::endmsg;
    }

    std::cout << std::endl;
  }

   return;

}

void TauTauAnalysis::BeginInputFile( const SInputData& ) throw( SError ) {

  m_logger << INFO << "Connecting input variables" << SLogger::endmsg;
  if (m_isData) {
    m_jetAK4.ConnectVariables(       m_recoTreeName.c_str(), Ntuple::JetBasic|Ntuple::JetAnalysis, (m_jetAK4Name + "_").c_str() );
    m_eventInfo.ConnectVariables(    m_recoTreeName.c_str(), Ntuple::EventInfoTrigger|Ntuple::EventInfoMETFilters, "" );
  }
  else {
    m_jetAK4.ConnectVariables(       m_recoTreeName.c_str(), Ntuple::JetBasic|Ntuple::JetAnalysis|Ntuple::JetTruth, (m_jetAK4Name + "_").c_str() );
    m_eventInfo.ConnectVariables(    m_recoTreeName.c_str(), Ntuple::EventInfoBasic|Ntuple::EventInfoTrigger|Ntuple::EventInfoMETFilters|Ntuple::EventInfoTruth, "" );
    m_genParticle.ConnectVariables(  m_recoTreeName.c_str(), Ntuple::GenParticleBasic, (m_genParticleName + "_").c_str() );
  }
  m_electron.ConnectVariables(     m_recoTreeName.c_str(), Ntuple::ElectronBasic|Ntuple::ElectronID|Ntuple::ElectronAdvancedID|Ntuple::ElectronBoostedIsolation, (m_electronName + "_").c_str() );
  m_muon.ConnectVariables(         m_recoTreeName.c_str(), Ntuple::MuonBasic|Ntuple::MuonID|Ntuple::MuonIsolation|Ntuple::MuonTrack|Ntuple::MuonBoostedIsolation, (m_muonName + "_").c_str() );
  m_tau.ConnectVariables(         m_recoTreeName.c_str(), Ntuple::TauBasic|Ntuple::TauID|Ntuple::TauAdvancedID, (m_tauName + "_").c_str() );

  m_missingEt.ConnectVariables(    m_recoTreeName.c_str(), Ntuple::MissingEtBasic|Ntuple::MissingEtAnalysis , (m_missingEtName + "_").c_str() );
  
  m_logger << INFO << "Connecting input variables completed" << SLogger::endmsg;

   return;

}

void TauTauAnalysis::ExecuteEvent( const SInputData&, Double_t ) throw( SError ) {

  m_logger << VERBOSE << "ExecuteEvent" << SLogger::endmsg;
  clearBranches();
  
  b_eventNumber = m_eventInfo.eventNumber;
  b_runNumber = m_eventInfo.runNumber;
  b_lumiBlock = m_eventInfo.lumiBlock;

  //  std::cout << b_eventNumber << " " << b_runNumber << " " << b_lumiBlock << std::endl;
  
  for (auto ch: m_catNames){
    fillCutflow("cutflow_" + ch, "histogram_" + ch, kBeforeCuts, 1);
  }
  
  // Cut 1: check for data if run/lumiblock in JSON
  if (m_isData) {
    if(!(isGoodEvent(m_eventInfo.runNumber, m_eventInfo.lumiBlock))){
      throw SError( SError::SkipEvent );
    }
  }

  for (auto ch: m_catNames){
    fillCutflow("cutflow_" + ch, "histogram_" + ch, kJSON, 1);
  }
  

  if (!m_isData){
    b_weight= getEventWeight();
    genFilterZtautau();
  }
  

  // Cut 2: pass trigger

  if (passTrigger()) {
    m_logger << VERBOSE << "Trigger pass" << SLogger::endmsg;
  }else{
    throw SError( SError::SkipEvent );
  }

  for (auto ch: m_catNames){
    fillCutflow("cutflow_" + ch, "histogram_" + ch, kTrigger, 1);
  }


  // Cut 3: pass MET filters

  if (passMETFilters()) {       
    m_logger << VERBOSE << "passMETFilters" << SLogger::endmsg;
  }else{
    throw SError( SError::SkipEvent );
  }

  for (auto ch: m_catNames){
    fillCutflow("cutflow_" + ch, "histogram_" + ch, kMetFilters, 1);
  }


  // Cut 4: muon

  std::vector<UZH::Muon> goodMuons;
  
  for( int i = 0; i < m_muon.N; ++i ){
    UZH::Muon mymuon( &m_muon, i );

    if (mymuon.pt() < m_muonPtCut) continue;
    if (fabs(mymuon.eta()) > m_muonEtaCut) continue;
    if (mymuon.isMediumMuon() < 0.5) continue;
    if (fabs(mymuon.d0()) > m_muonD0Cut) continue;
    if (fabs(mymuon.dz()) > m_muonDzCut) continue;
    if (mymuon.SemileptonicPFIso() / mymuon.pt() > m_muonIsoCut) continue;

    goodMuons.push_back(mymuon);
  }



  // Cut 5: electron

  std::vector<UZH::Electron> goodElectrons;
  
  for ( int i = 0; i < m_electron.N; ++i ) {
    UZH::Electron myelectron( &m_electron, i );
    if (myelectron.pt() < m_electronPtCut) continue;
    if (fabs(myelectron.eta()) > m_electronEtaCut) continue;
    if (fabs(myelectron.d0()) > m_electronD0Cut) continue;
    if (fabs(myelectron.dz()) > m_electronDzCut) continue;
    if (myelectron.passConversionVeto()!=1) continue;
    if (myelectron.expectedMissingInnerHits()>1) continue;
    if (myelectron.SemileptonicPFIso() / myelectron.pt() > m_electronIsoCut) continue;
    if (myelectron.nonTrigMVAID() < 0.5) continue;
	  
    goodElectrons.push_back(myelectron);
      
  }


  // Make sure that there is no events with good muon and good electron at the same time

  TString event_type = "none";

  if(goodMuons.size()==1 && goodElectrons.size()==0){
    event_type = "mutau";
  }else if(goodMuons.size()==0 && goodElectrons.size()==1){
    event_type = "eletau";
  }else{
    throw SError( SError::SkipEvent );
  }

  fillCutflow("cutflow_" + event_type, "histogram_" + event_type, kLepton, 1);
  

  // Cut 6: taus

  std::vector<UZH::Tau> goodTaus;
 
  for ( int i = 0; i <   (m_tau.N); ++i ) {
    UZH::Tau mytau( &m_tau, i );
    if(mytau.TauType()!=1) continue;
    if(mytau.pt() < m_tauPtCut) continue;
    if(fabs(mytau.eta()) > m_tauEtaCut) continue;
    if(fabs(mytau.dz()) > m_tauDzCut) continue;
    if(mytau.decayModeFinding() < 0.5) continue;
    if(fabs(mytau.charge()) != 1) continue;

    if(event_type=="mutau"){
      if(mytau.againstMuonTight3() < 0.5) continue;
      if(mytau.againstElectronVLooseMVA6() < 0.5) continue;
    }else if(event_type=="eletau"){
      if(mytau.againstMuonLoose3() < 0.5) continue;
      if(mytau.againstElectronTightMVA6() < 0.5) continue;
    }

    if(mytau.byTightIsolationMVArun2v1DBoldDMwLT() < 0.5) continue;

    goodTaus.push_back(mytau);
  }
  



  if(goodTaus.size()==1){
  }else{
    throw SError( SError::SkipEvent );
  }

  fillCutflow("cutflow_" + event_type, "histogram_" + event_type, kTau, 1);

  
  // Cut 7: Delta R

  if(event_type == "mutau"){
    if(goodMuons[0].tlv().DeltaR(goodTaus[0].tlv()) < 0.5){
      throw SError( SError::SkipEvent );
    }
  }else if(event_type=="eletau"){
    if(goodElectrons[0].tlv().DeltaR(goodTaus[0].tlv()) < 0.5){
      throw SError( SError::SkipEvent );
    }
  }


  fillCutflow("cutflow_" + event_type, "histogram_" + event_type, kLeptonDR, 1);



  std::cout << "\t" << b_eventNumber << " " << b_runNumber << " " << b_lumiBlock  << "  -> pass !" << std::endl;


  UZH::MissingEt goodMet( &m_missingEt, 0 );

  std::vector<UZH::Jet> goodJetsAK4;
  
  for ( int i = 0; i < (m_jetAK4.N); ++i ) {
    UZH::Jet myjetak4( &m_jetAK4, i );
    if (fabs(myjetak4.eta()) > m_AK4jetEtaCut) continue;
    if (myjetak4.pt() < m_AK4jetPtCut) continue;
    //    if (myjetak4.IDTight()) goodJetsAK4.push_back(myjetak4);
  }



  if (event_type=="mutau"){
    
    FillBranches( "mutau", goodJetsAK4[0], b_weight,  b_weightGen,  b_weightPU, b_runNumber, b_eventNumber, b_lumiBlock,  goodTaus[0], goodMuons[0].tlv() , goodMet);
    mu_tau++;

  }else if( event_type=="eletau"){
    
    FillBranches( "eletau", goodJetsAK4[0], b_weight,  b_weightGen,  b_weightPU, b_runNumber, b_eventNumber, b_lumiBlock,  goodTaus[0], goodElectrons[0].tlv(), goodMet );
    ele_tau++;
    
  }
  
  return;
}
  


bool TauTauAnalysis::isGoodEvent(int runNumber, int lumiSection) {
  
  bool isGood = true;
  if (m_isData) {
    isGood = m_grl.HasRunLumiBlock( runNumber, lumiSection );
    if( !isGood ) {
      m_logger << WARNING << "Bad event! Run: " << runNumber <<  " - Lumi Section: " << lumiSection << SLogger::endmsg;
      // throw SError( SError::SkipEvent );
    }
    else m_logger << VERBOSE << "Good event! Run: " << runNumber <<  " - Lumi Section: " << lumiSection << SLogger::endmsg;
  }
  
  return isGood;
  
}



bool TauTauAnalysis::passTrigger() {
  
  bool passTrigger = false;
  
  for (std::map<std::string,bool>::iterator it = (m_eventInfo.trigDecision)->begin(); it != (m_eventInfo.trigDecision)->end(); ++it){
    for (unsigned int t = 0; t < m_triggerNames.size(); ++t ){
      if ((it->first).find(m_triggerNames[t]) != std::string::npos) {
        if (it->second == true) {
          m_logger << VERBOSE << "Trigger pass: " << (it->first) << SLogger::endmsg;
          passTrigger = true;
          return passTrigger;
        }
      }
    }
  }
  
  return passTrigger;
  
}


bool TauTauAnalysis::passMETFilters() {
  
  bool passMetFilters = true;
  
  // using only what's recommended in https://twiki.cern.ch/twiki/bin/viewauth/CMS/MissingETOptionalFiltersRun2
    
  if( !(m_eventInfo.PV_filter) ) {
    passMetFilters = false;
    m_logger << VERBOSE << "PV_filter" << SLogger::endmsg;
  }
  if( !(m_eventInfo.passFilter_CSCHalo) ) {
    passMetFilters = false;
    m_logger << VERBOSE << "passFilter_CSCHalo" << SLogger::endmsg;
  }
  if( !(m_eventInfo.passFilter_HBHELoose) ) {
    passMetFilters = false;
    m_logger << VERBOSE << "passFilter_HBHELoose" << SLogger::endmsg;
  }
  if( !(m_eventInfo.passFilter_HBHEIso) ) {
    passMetFilters = false;
    m_logger << VERBOSE << "passFilter_HBHEIso" << SLogger::endmsg;
  }
  if( !(m_eventInfo.passFilter_EEBadSc) ) {
    passMetFilters = false;
    m_logger << VERBOSE << "passFilter_EEBadSc" << SLogger::endmsg;
  }
 
  if( !(m_eventInfo.passFilter_globalTightHalo2016) ){
    passMetFilters = false;
    m_logger << VERBOSE << "passFilter_EEBadSc" << SLogger::endmsg;
  }

  if( !(m_eventInfo.passFilter_chargedHadronTrackResolution) ){
    passMetFilters = false;
    m_logger << VERBOSE << "passFilter_EEBadSc" << SLogger::endmsg;
  }

  if( !(m_eventInfo.passFilter_muonBadTrack) ) {        
    passMetFilters = false;
    m_logger << VERBOSE << "passFilter_EEBadSc" << SLogger::endmsg;
  } 
  return passMetFilters;
  
}


double TauTauAnalysis::getEventWeight() {
  
  double weight = 1.;
  for( unsigned int v = 0; v < (m_eventInfo.actualIntPerXing)->size(); ++v ){
    
    if ( (*m_eventInfo.bunchCrossing)[v] == 0 ) {
      b_weightPU = m_pileupReweightingTool.getPileUpweight( (*m_eventInfo.actualIntPerXing)[v] );
      m_logger << VERBOSE << "Weight: " << b_weightPU << " for true: " << (*m_eventInfo.actualIntPerXing)[v] << SLogger::endmsg;
      //std::cout << "Weight: " << b_weightPU << " for true: " << (*m_eventInfo.actualIntPerXing)[v] <<std::endl;
      break;
    }
  }
  b_weightGen = (m_eventInfo.genEventWeight < 0) ? -1 : 1; 
  weight *= b_weightPU*b_weightGen;
  
  return weight;
  
}

void TauTauAnalysis::clearBranches() {

  b_weight = 1.;
  b_weightGen = 1.;
  b_weightPU = 1.;
  //  b_weightBtag = 1.;
  //  b_weightBtag_veto = 1.;
  
  b_runNumber = -99;;
  b_eventNumber = -99;
  b_lumiBlock = -99;
  
  GenEvent_Htata_filter=false;
  GenEvent_Ztata_filter=false;
  
  N_AK4=-99;

  //  for(unsigned int ch=0;ch< channels_.size();ch++){
  //  for(auto ch: channels_){  

    b_weight_ = 1.;
    b_weightGen_ = 1.;
    b_weightPU_ = 1.;
    //    b_weightBtag_ = 1.;
    //    b_weightBtag_veto_ = 1.;
    b_weightLepID_ = 1.;
    b_weightLepIso_ = 1.;

    b_runNumber_ = -99;
    b_eventNumber_ = -99;
    b_lumiBlock_ = -99;
  
    b_tau_pt_ =-99;
    b_tau_eta_ =-99;
    b_tau_phi_ =-99;
    b_tau_Iso_ =-99;
    b_tau_IsoRaw_ =-99;
    b_tau_againstEle_ =-99;
    b_tau_againstMu_ =-99;
    b_seclepton_pt_ =-99;
    b_seclepton_eta_ =-99;
    b_seclepton_phi_ =-99;
    b_met_ =-99;
    b_met_phi_ =-99;
    b_vis_mass_ll_ =-99;
    b_dR_ll_ =-99;

    b_H_Mass_SVFit_ =-99;
    b_H_Pt_SVFit_ =-99;
    b_H_Eta_SVFit_ =-99;
    b_H_Phi_SVFit_ =-99;

    b_N_AK4_ = -99 ;
    b_PV_N_ =-99;
    b_GenEvent_Htata_=false;
    b_GenEvent_Ztata_=false;
    b_ChannelInt_ =-99;
    //  }
  
}

//void TauTauAnalysis::fillCutflow( const std::string histName, const std::string dirName, const Int_t id, const Double_t weight=1.){
void TauTauAnalysis::fillCutflow(TString histName, TString dirName, const Int_t id, const Double_t weight){

  //  std::cout << "\t" << histName << " "<<dirName << " " << id << " " << weight << std::endl;
  //  Hist( histName.c_str(), dirName.c_str() )->Fill( id+1, weight );
  Hist( histName, dirName )->Fill( id+1, weight );
}


void TauTauAnalysis::FillBranches( const std::string& channel,  const UZH::Jet& Jet, const double& b_weight, const double& b_weightGen,  const double& b_weightPU, const double& b_runNumber, const double& b_eventNumber,const double& b_lumiBlock,  const UZH::Tau& tau,const  TLorentzVector& lepton, const UZH::MissingEt& met ){


  b_weight_ = b_weight;
  b_weightGen_ =  b_weightGen;
  b_weightPU_ =  b_weightPU;
  //  b_weightBtag_ =   b_weightBtag;
  //  b_weightBtag_veto_ =   b_weightBtag_veto;
  
  b_runNumber_ = b_runNumber;
  b_eventNumber_ = b_eventNumber;
  b_lumiBlock_ = b_lumiBlock;
  
  b_tau_pt_=tau.tlv().Pt();
  b_tau_eta_=tau.tlv().Eta();
  b_tau_phi_=tau.tlv().Phi();
  b_tau_IsoRaw_=tau.byIsolationMVArun2v1PWnewDMwLTraw();
  b_tau_Iso_=tau.byVLooseIsolationMVArun2v1PWnewDMwLT();
  b_tau_againstEle_=tau.againstElectronVLooseMVA6();
  b_tau_againstMu_=tau.againstMuonLoose3();

  b_seclepton_pt_=lepton.Pt();
  b_seclepton_eta_=lepton.Eta();// FIX 
  b_seclepton_phi_=lepton.Phi();// FIX 
  
  b_vis_mass_ll_=(lepton +tau.tlv()).M();
  b_dR_ll_= lepton.DeltaR(tau.tlv());

  b_met_ =met.et();
  b_met_phi_ =met.phi();
  b_N_AK4_ = N_AK4;

  if (channel=="mutau") { 
    b_ChannelInt_ = 0; 
    if (!m_isData) {
      
      b_weightLepID_= m_ScaleFactorTool.get_ScaleFactor_IDMuIchep(lepton.Pt(),fabs(lepton.Eta()));
      b_weightLepIso_= m_ScaleFactorTool.get_ScaleFactor_IsoMuIchep(lepton.Pt(),fabs(lepton.Eta()));
    
    }
  }
  if (channel=="eletau")  {   
    b_ChannelInt_ = 1;
    
    if (!m_isData) {  
      b_weightLepID_= m_ScaleFactorTool.get_ScaleFactor_IDEleIchep(lepton.Pt(),fabs(lepton.Eta()));
    }
  }

  b_PV_N_= m_eventInfo.PV_N;
    
  
  bool doSVfit= false;
  if (doSVfit){
    TLorentzVector H_ll;
    H_ll.SetPtEtaPhiM(0,0,0,0);
  
    H_ll=applySVFitSemileptonic(met.cov00(),met.cov10(),met.cov11(),met.et(),met.phi(),tau.tlv(),lepton);

    b_H_Mass_SVFit_=H_ll.M();
    b_H_Pt_SVFit_=H_ll.Pt();
    b_H_Eta_SVFit_=H_ll.Eta();
    b_H_Phi_SVFit_=H_ll.Phi();
  }

  if (!m_isData){
  
    b_GenEvent_Htata_ = GenEvent_Htata_filter ;
    b_GenEvent_Ztata_ = GenEvent_Ztata_filter ;
   }


}



TLorentzVector TauTauAnalysis::applySVFitSemileptonic(float cov00, float cov10, float cov11,  float met, float met_phi, TLorentzVector lep1 , TLorentzVector lep2){
  // std::cout<<"inside applySVFitSemileptonic "<<std::endl;
  
  TLorentzVector   lBoson4;
  lBoson4.SetPtEtaPhiE(0,0,0,0);

  TMatrixD covMETraw(2,2);
  covMETraw[0][0]=  cov00;
  covMETraw[1][0]=  cov10;
  covMETraw[0][1]=  cov10;
  covMETraw[1][1]=  cov11;

  float lcov00 =  cov00;
  float lcov10 =  cov10;
  float lcov01 =  cov10;
  float lcov11 =  cov11;
  
  
  TLorentzVector   nullo;
  nullo.SetPtEtaPhiE(0,0,0,0);
  if(lcov00*lcov11-lcov01*lcov01 == 0) {
    std::cout<<"covMat det null "<<std::endl;
    return nullo;
  }
  

  NSVfitStandalone::Vector measuredMET(met *TMath::Cos(met_phi), met *TMath::Sin(met_phi), 0); 
  // setup measure tau lepton vectors 
  NSVfitStandalone::LorentzVector l1(lep1.Px(), lep1.Py(), lep1.Pz(), TMath::Sqrt(lep1.M()*lep1.M()+lep1.Px()*lep1.Px()+lep1.Py()*lep1.Py()+lep1.Pz()*lep1.Pz()));
  NSVfitStandalone::LorentzVector l2(lep2.Px(), lep2.Py(), lep2.Pz(), TMath::Sqrt(lep2.M()*lep2.M()+lep2.Px()*lep2.Px()+lep2.Py()*lep2.Py()+lep2.Pz()*lep2.Pz()));
  std::vector<NSVfitStandalone::MeasuredTauLepton> measuredTauLeptons;
  measuredTauLeptons.push_back(NSVfitStandalone::MeasuredTauLepton(NSVfitStandalone::kHadDecay, l1));
  measuredTauLeptons.push_back(NSVfitStandalone::MeasuredTauLepton(NSVfitStandalone::kLepDecay, l2));

  // construct the class object from the minimal necesarry information
  NSVfitStandaloneAlgorithm algo(measuredTauLeptons, measuredMET, covMETraw, 0);

  // apply customized configurations if wanted (examples are given below)
  algo.addLogM(false);

  // integration by markov chain MC
  algo.integrateMarkovChain();
  if(algo.isValidSolution()){
   
    lBoson4.SetPtEtaPhiM( algo.pt(), algo.eta(), algo.phi(), algo.getMass());
  }
  else{
    std::cout << "sorry -- status of NLL is not valid [" << algo.isValidSolution() << "]" << std::endl;
   lBoson4.SetPtEtaPhiM( 0.,0,0,0);
  }
  
  measuredTauLeptons.clear();
  return   lBoson4 ;
  
}


void TauTauAnalysis::genFilterZtautau() {
  
  std::vector<UZH::GenParticle> goodGenPart;
  
  for ( int p = 0; p <   (m_genParticle.N) ; ++p ) {
    UZH::GenParticle mygoodGenPart( &m_genParticle, p );

    if( fabs(mygoodGenPart.pdgId()) == 15 ){
      if ( mygoodGenPart.mother()[0]==25){
	// std::cout << " Inside H : mygoodGenPart.pdgId() " <<mygoodGenPart.pdgId() << " mygoodGenPart.mother()[0] " << (mygoodGenPart.mother())[0] << std::endl;
	GenEvent_Htata_filter= true;
      }
      if( mygoodGenPart.mother()[0]==23){
	// std::cout << " Inside Z : mygoodGenPart.pdgId() " <<mygoodGenPart.pdgId() << " mygoodGenPart.mother()[0] " << (mygoodGenPart.mother())[0] << std::endl;
	GenEvent_Ztata_filter= true;
      }
    } 
  }
}
